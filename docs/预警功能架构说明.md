# 预警功能架构说明

## 架构设计理念

### 核心原则

**职责分离**: 业务逻辑在后端,展示逻辑在前端

- **后端职责**: 预警规则查询、预警条件判断、数据标记
- **前端职责**: 样式应用、用户交互

### 为什么将预警逻辑放在后端?

#### 1. 性能优化
- 后端处理数据更高效,避免前端遍历大量数据
- 减少前端计算压力,提升页面响应速度

#### 2. 业务逻辑集中
- 预警判断是业务逻辑,应该在后端统一处理
- 便于维护和调试,逻辑修改只需改后端

#### 3. 数据一致性
- 后端统一处理,确保预警逻辑的一致性
- 避免前后端逻辑不一致导致的问题

#### 4. 安全性
- 预警规则在后端处理,不暴露给前端
- 防止前端篡改预警逻辑

#### 5. 可扩展性
- 后端可以轻松扩展更复杂的预警逻辑
- 支持跨表查询、复杂计算等

## 技术架构

### 数据流程图

```
┌─────────────┐
│   前端页面   │
└──────┬──────┘
       │ 1. 发起查询请求
       ↓
┌─────────────────────────────────────────┐
│           后端 Controller                │
└──────────────────┬──────────────────────┘
                   │ 2. 调用Service
                   ↓
┌─────────────────────────────────────────┐
│           Service.GetPageData            │
│  ┌─────────────────────────────────┐   │
│  │  QueryRelativeExpression        │   │ 3. 查询数据
│  └─────────────────────────────────┘   │
│  ┌─────────────────────────────────┐   │
│  │  GetPageDataOnExecuted          │   │ 4. 查询后处理
│  │  ├─ 业务逻辑处理                │   │
│  │  └─ ApplyAlertWarningToData     │   │ 5. 应用预警标记
│  └─────────────────────────────────┘   │
└──────────────────┬──────────────────────┘
                   │ 6. 返回数据(含ShouldAlert字段)
                   ↓
┌─────────────────────────────────────────┐
│           前端 searchAfter               │
│  applyAlertWarningStyle(columns)        │ 7. 应用样式
└─────────────────────────────────────────┘
```

### 核心组件

#### 1. AlertWarningHelper (后端)

**位置**: `api\HDPro.CY.Order\Services\Common\AlertWarningHelper.cs`

**职责**:
- 为数据行添加预警标记
- 检查数据行是否匹配预警规则
- 判断完成状态

**核心方法**:
```csharp
public static void ApplyAlertWarning<T>(
    List<T> rows, 
    List<OCP_AlertRules> rules, 
    ILogger logger = null
) where T : class
```

#### 2. Service集成 (后端)

**位置**: 各Service的Partial文件

**职责**:
- 在`GetPageDataOnExecuted`中调用预警助手
- 获取预警规则
- 为数据添加预警标记

**示例**:
```csharp
GetPageDataOnExecuted = (PageGridData<OCP_TechManagement> grid) =>
{
    if (grid.rows != null && grid.rows.Any())
    {
        ApplyAlertWarningToData(grid.rows);
    }
};
```

#### 3. 实体类扩展 (后端)

**位置**: 实体类的partial文件

**职责**:
- 添加`ShouldAlert`属性
- 标记为`[NotMapped]`,不映射到数据库

**示例**:
```csharp
[NotMapped]
public bool ShouldAlert { get; set; }
```

#### 4. alertWarning.js (前端)

**位置**: `web.vite\src\utils\alertWarning.js`

**职责**:
- 根据`ShouldAlert`字段应用样式
- 支持自定义样式

**核心方法**:
```javascript
export function applyAlertWarningStyle(columns, customStyle = null)
```

#### 5. Vue页面集成 (前端)

**位置**: 各Vue页面文件

**职责**:
- 在`searchAfter`中调用样式应用函数

**示例**:
```javascript
const searchAfter = async (rows, result) => {
  applyAlertWarningStyle(columns)
  return true
}
```

## 预警规则配置

### 规则表结构

**表名**: `OCP_AlertRules`

**关键字段**:
- `AlertPage`: 预警页面名称
- `FieldName`: 日期字段名(多个用逗号分隔)
- `DayCount`: 超期天数阈值
- `advanceWarningDays`: 提前预警天数
- `FinishStatusField`: 完成状态字段
- `ConditionType`: 完成判定方式
- `ConditionValue`: 完成判定值
- `TaskStatus`: 任务状态(0=暂停, 1=启用)

### 判断逻辑

#### 1. 完成状态检查
```
如果已完成 → 不预警
```

#### 2. 超期检查
```
当前日期 - 目标日期 > DayCount → 预警
```

#### 3. 提前预警检查
```
目标日期 - 当前日期 <= advanceWarningDays → 预警
```

## 扩展指南

### 添加新页面预警

1. 为实体类添加`ShouldAlert`属性
2. 在Service的`GetPageDataOnExecuted`中集成预警逻辑
3. 在前端页面的`searchAfter`中应用样式
4. 在`OCP_AlertRules`表中配置规则

### 自定义预警样式

```javascript
applyAlertWarningStyle(columns, {
  backgroundColor: '#ffecec',
  color: '#f5222d'
})
```

### 添加新的判断条件

在`AlertWarningHelper.CheckRowMatchesRule`方法中添加新的判断逻辑。

## 优势总结

1. **架构清晰**: 前后端职责明确,易于理解和维护
2. **性能优秀**: 后端处理,前端只负责展示
3. **扩展性强**: 支持多种预警条件和自定义逻辑
4. **通用性好**: 一次开发,多页面复用
5. **配置化**: 通过数据库配置,无需修改代码

